{% extends "base.html" %}

{% block title %}Create Playlist{% endblock %}

{% block content %}
<h2>➕ Create New Smart Playlist</h2>
<div class="page-container">
<form method="post" class="form-container" onsubmit="console.log('Submitting form with serialized rules:', document.getElementById('rules_json').value); return serializeRules()">
  <label>
    Playlist Name:
    <input type="text" name="name" required class="form-input">
  </label>
  <br><br>


  <label>
    Track Limit:
    <select name="limit" required class="form-select">
      <option value="50">50</option>
      <option value="100">100</option>
      <option value="500">500</option>
      <option value="1000">1000</option>
      <option value="9000" selected>9000</option>
      <option value="no_limit">No Limit</option>
    </select>
    <input type="number" name="custom_limit" min="1" max="9000" step="1" class="form-input" placeholder="Custom limit (1-9000)">
    <small>(Leave empty to use the dropdown)</small>
  </label>

  <br><br>
  <label>
    Sort By:
    <div id="sort-container">
      <div class="sort-row">
        <select name="sort_by[]" class="form-select">
          <option value="album_id" selected>Album ID</option>
          <option value="artist">Artist</option>
          <option value="track">Track</option>
          <option value="added_at">Date Added</option>
          <option value="plays">Plays</option>
          <option value="last_played_at">Last Played</option>
          <option value="first_played_at">First Played</option>
          <option value="disc_number">Disc Number</option>
          <option value="track_number">Track Number</option>
        </select>
        <select name="sort_direction[]" class="form-select">
          <option value="asc" selected>Ascending</option>
          <option value="desc">Descending</option>
        </select>
        <button type="button" class="btn-secondary" onclick="removeSort(this)">−</button>
      </div>
    </div>
    <button type="button" class="btn-secondary" onclick="addSort()">➕ Add Sort Rule</button>
  </label>

  <hr>
  <h3>Filter Rules</h3>

  <div id="rules-container">
    <div class="rule-group" data-match="all">
      <label>
        Match
        <select class="match-selector form-select">
          <option value="all">all</option>
          <option value="any">any</option>
        </select>
      </label>
      <div class="rule-conditions">
        <div class="rule-row">
          <select name="field[]" class="form-select">
            <option value="artist">Artist</option>
            <option value="album">Album</option>
            <option value="track">Track</option>
            <option value="track_source">Track Source</option>
            <option value="library_origin">Library Origin</option>
            <option value="is_liked">Is Liked</option>
            <option value="added_after">Date Added After</option>
            <option value="added_before">Date Added Before</option>
            <option value="added_in_last">Date Added In Last X</option>
            <option value="last_played_in_last">Last Played In Last X</option>
            <option value="min_plays">Min Plays</option>
            <option value="max_plays">Max Plays</option>
            <option value="plays">Plays</option>
            <option value="last_played">Last Played</option>
            <option value="first_played">First Played</option>
          </select>

          <select name="operator[]" class="form-select">
            <option value="eq">is</option>
            <option value="is_not">is not</option>
            <option value="contains">contains</option>
            <option value="not_contains">does not contain</option>
            <option value="gt">greater than</option>
            <option value="lt">less than</option>
            <option value="gte">greater than or equal to</option>
            <option value="lte">less than or equal to</option>
          </select>

          <input type="text" name="value[]" class="form-input">
          <button type="button" class="btn-secondary" onclick="removeRule(this)">−</button>
        </div>
      </div>
      <button type="button" class="btn-secondary" onclick="addRule(this)">➕ Add Rule</button>
      <button type="button" class="btn-secondary" onclick="addGroup(this)">➕ Add Nested Group</button>
    </div>
  </div>

  <script>
    function addRule(button) {
      const container = button.parentElement.querySelector('.rule-conditions');
      const rule = container.querySelector('.rule-row').cloneNode(true);
      rule.querySelectorAll('input').forEach(input => input.value = '');
      rule.querySelectorAll('[name="unit[]"]').forEach(sel => sel.selectedIndex = 0);
      container.appendChild(rule);
      initializeRuleRow(rule);
    }

    function removeRule(button) {
      const container = button.parentElement.parentElement;
      if (container.children.length > 1) {
        button.parentElement.remove();
      }
    }

    function addSort() {
      const container = document.getElementById('sort-container');
      const sortRow = container.querySelector('.sort-row').cloneNode(true);
      container.appendChild(sortRow);
    }

    function removeSort(button) {
      const container = document.getElementById('sort-container');
      if (container.children.length > 1) {
        button.parentElement.remove();
      }
    }

    function addGroup(button) {
      // Clone a fresh top-level group as a template
      const template = document.querySelector('#rules-container .rule-group').cloneNode(true);

      // 1) Remove any nested groups from the template so we don't duplicate subgroups
      template.querySelectorAll('.rule-group').forEach(g => g.remove());

      // 2) Reset the match selector to 'all' for the new subgroup
      const matchSel = template.querySelector('.match-selector');
      if (matchSel) matchSel.value = 'all';

      // 3) Keep only a single clean rule row and reset its inputs
      const rulesContainer = template.querySelector('.rule-conditions');
      if (rulesContainer) {
        const ruleRows = Array.from(rulesContainer.querySelectorAll('.rule-row'));
        // Remove extra rule rows if any
        ruleRows.slice(1).forEach(r => r.remove());

        // Reset the remaining rule row to defaults (field/operator/value)
        const row = ruleRows[0];
        if (row) {
          // reset selects and inputs
          row.querySelectorAll('input').forEach(inp => { inp.value = ''; });
          row.querySelectorAll('[name="unit[]"]').forEach(sel => sel.selectedIndex = 0);

          // Reset the field to the first option then rebuild its value control
          const fieldSel = row.querySelector('[name="field[]"]');
          if (fieldSel) {
            fieldSel.selectedIndex = 0;
            buildValueControl(row, fieldSel.value);
          }

          // Ensure operator list matches the default field configuration
          const defaultField = fieldSel ? fieldSel.value : 'artist';
          const cfg = FIELD_CONFIG[defaultField] || { operators: ['eq','is_not','contains','not_contains'] };
          buildOperatorSelect(row, cfg.operators);
        }
      }

      // 4) Append this clean subgroup as a direct child of the current group's container
      // Place it next to the existing buttons inside the current .rule-group
      button.parentElement.appendChild(template);
    }

    // --- Context-aware rule inputs ---
    const FIELD_CONFIG = {
      // free text fields
      artist: { type: 'text', operators: ['eq','is_not','contains','not_contains'] },
      album:  { type: 'text', operators: ['eq','is_not','contains','not_contains'] },
      track:  { type: 'text', operators: ['eq','is_not','contains','not_contains'] },

      // enums / booleans
      track_source: { type: 'enum', values: [ ['library','Library'], ['non_library','Non-library'], ['both','Both'] ], operators: ['eq','is_not'] },
      library_origin: { type: 'enum', values: [['non_library','Non-Library'],['liked_only','Liked Only'],['album','Album']], operators: ['eq','is_not'] },
      is_liked:     { type: 'enum', values: [ ['true','True'], ['false','False'] ], operators: ['eq'] },

      // dates
      added_after:  { type: 'date', operators: ['gt','gte','eq'] },
      added_before: { type: 'date', operators: ['lt','lte','eq'] },
      last_played:  { type: 'date', operators: ['gt','gte','lt','lte','eq'] },
      first_played: { type: 'date', operators: ['gt','gte','lt','lte','eq'] },

      // numbers
      added_in_last: { type: 'number_unit', attrs: { min: 0, step: 1 }, units: [['days','Days'], ['weeks','Weeks'], ['months','Months']], operators: ['eq'] },
      last_played_in_last: { type: 'number_unit', attrs: { min: 0, step: 1 }, units: [['days','Days'], ['weeks','Weeks'], ['months','Months']], operators: ['eq','is_not'] },
      min_plays: { type: 'number', attrs: { min: 0, step: 1 }, operators: ['gte','gt','eq'] },
      max_plays: { type: 'number', attrs: { min: 0, step: 1 }, operators: ['lte','lt','eq'] },
      plays:     { type: 'number', attrs: { min: 0, step: 1 }, operators: ['eq','gte','lte','gt','lt'] }
    };

    function buildOperatorSelect(row, allowed) {
      const opSel = row.querySelector('[name="operator[]"]');
      const current = opSel.value;
      opSel.innerHTML = '';
      const labels = { eq: 'is', is_not: 'is not', contains: 'contains', not_contains: 'does not contain', gt: 'greater than', lt: 'less than', gte: 'greater than or equal to', lte: 'less than or equal to' };
      allowed.forEach(op => {
        const opt = document.createElement('option');
        opt.value = op; opt.textContent = labels[op] || op;
        opSel.appendChild(opt);
      });
      if (allowed.includes(current)) opSel.value = current;
    }

    function buildValueControl(row, field) {
      const cfg = FIELD_CONFIG[field] || { type: 'text', operators: ['eq','is_not','contains','not_contains'] };

      // Remove any existing value UI entirely (container + stray inputs)
      const oldContainer = row.querySelector('.value-container');
      if (oldContainer) oldContainer.remove();
      row.querySelectorAll('[name="value[]"], [name="unit[]"]').forEach(el => el.remove());

      // Always create a fresh container and insert it before the remove button
      const container = document.createElement('span');
      container.className = 'value-container';
      const removeBtn = row.querySelector('button.btn-secondary');

      if (cfg.type === 'enum') {
        const sel = document.createElement('select');
        sel.name = 'value[]';
        sel.className = 'form-select';
        cfg.values.forEach(([val,label]) => {
          const opt = document.createElement('option');
          opt.value = val; opt.textContent = label; sel.appendChild(opt);
        });
        container.appendChild(sel);

      } else if (cfg.type === 'date') {
        const inp = document.createElement('input');
        inp.type = 'date';
        inp.name = 'value[]';
        inp.className = 'form-input';
        container.appendChild(inp);

      } else if (cfg.type === 'number_unit') {
        const num = document.createElement('input');
        num.type = 'number';
        num.name = 'value[]';
        num.className = 'form-input';
        if (cfg.attrs) Object.entries(cfg.attrs).forEach(([k,v]) => num.setAttribute(k, v));
        container.appendChild(num);

        const unitSel = document.createElement('select');
        unitSel.name = 'unit[]';
        unitSel.className = 'form-select';
        (cfg.units || [['days','Days'],['weeks','Weeks'],['months','Months']]).forEach(([val,label]) => {
          const opt = document.createElement('option');
          opt.value = val; opt.textContent = label; unitSel.appendChild(opt);
        });
        container.appendChild(unitSel);

      } else if (cfg.type === 'number') {
        const inp = document.createElement('input');
        inp.type = 'number';
        inp.name = 'value[]';
        inp.className = 'form-input';
        if (cfg.attrs) Object.entries(cfg.attrs).forEach(([k,v]) => inp.setAttribute(k, v));
        container.appendChild(inp);

      } else {
        const inp = document.createElement('input');
        inp.type = 'text';
        inp.name = 'value[]';
        inp.className = 'form-input';
        container.appendChild(inp);
      }

      // Insert container before the remove button (keeps layout consistent)
      row.insertBefore(container, removeBtn);

      buildOperatorSelect(row, cfg.operators);
    }

    function initializeRuleRow(row) {
      const fieldSel = row.querySelector('[name="field[]"]');
      buildValueControl(row, fieldSel.value);
    }

    // Watch for field changes to swap in the right control
    document.addEventListener('change', function(e) {
      if (e.target && e.target.name === 'field[]') {
        const row = e.target.closest('.rule-row');
        buildValueControl(row, e.target.value);
      }
    });

    // Initialize existing rule rows on page load
    document.addEventListener('DOMContentLoaded', function() {
      document.querySelectorAll('.rule-row').forEach(initializeRuleRow);
    });

    function serializeGroup(groupElement) {
      const group = {
        match: groupElement.querySelector(".match-selector").value,
        conditions: [],
      };

      // Serialize direct rules only from this group's rule-conditions container
      const rulesContainer = groupElement.querySelector(".rule-conditions");
      const rows = rulesContainer ? rulesContainer.querySelectorAll(".rule-row") : [];
      rows.forEach(row => {
        const field = row.querySelector('[name="field[]"]').value;
        const operator = row.querySelector('[name="operator[]"]').value;
        const valueEl = row.querySelector('[name="value[]"]');
        const unitEl  = row.querySelector('[name="unit[]"]');
        const value = valueEl ? valueEl.value : '';
        const unit  = unitEl ? unitEl.value : undefined;

        // basic validation for number+unit field
        if (field === 'added_in_last' || field === 'last_played_in_last') {
          const n = parseInt(value, 10);
          if (Number.isNaN(n) || n < 0) return; // skip invalid row
          if (!unit) return; // must have unit
          group.conditions.push({ field, operator, value: n, unit });
        } else if (field && operator && value !== '') {
          group.conditions.push({ field, operator, value });
        }
      });

      // Now serialize direct nested groups (not any rule-row that got duplicated)
      // Alternatively: find direct children .rule-group that are not inside .rule-conditions
      groupElement.querySelectorAll(':scope > .rule-group').forEach(subgroup => {
        group.conditions.push(serializeGroup(subgroup));
      });

      return group;
    }

    function serializeRules() {
      const topGroup = document.querySelector("#rules-container .rule-group");
      const rules = serializeGroup(topGroup);

      // Determine limit: prefer valid custom_limit (1-9000), else fallback to dropdown
      const limitSelect = document.querySelector('[name="limit"]');
      const customLimitEl = document.querySelector('[name="custom_limit"]');
      const customValRaw = customLimitEl ? customLimitEl.value.trim() : '';

      let limit = null;
      if (customValRaw !== '') {
        const n = parseInt(customValRaw, 10);
        if (!Number.isNaN(n) && n >= 1 && n <= 9000) {
          limit = n;
        } else {
          alert('Custom limit must be an integer between 1 and 9000.');
          return false;
        }
      } else {
        // Fallback to dropdown; map "no_limit" to 9000 (max allowed)
        const sel = limitSelect ? limitSelect.value : '9000';
        limit = sel === 'no_limit' ? 9000 : parseInt(sel, 10);
      }

      rules.limit = limit;

      // Sort rules
      rules.sort = Array.from(document.querySelectorAll('#sort-container .sort-row')).map(row => ({
        by: row.querySelector('[name="sort_by[]"]').value,
        direction: row.querySelector('[name="sort_direction[]"]').value
      }));

      // NOTE: Backend should handle `added_in_last` using the provided unit
      // e.g., build an interval like `${value} ${unit}` in SQL.
      document.getElementById("rules_json").value = JSON.stringify(rules);
      return true;
    }
  </script>

  <input type="hidden" name="rules_json" id="rules_json">
  <button type="submit" class="btn">🎶 Create Playlist</button>
</form>

<p><a href="/dashboard/playlists" class="btn">⬅️ Back to Playlists</a></p>
</div>
{% include "footer.html" %}
{% endblock %}